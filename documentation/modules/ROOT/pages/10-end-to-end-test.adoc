= End To End Test
include::_attributes.adoc[]

[#introduction]
== Introduction

So far, you have deployed your application and CICD pipelines; additionally you have created webhook and they are, apparently, working properly but we will never know for sure unless we make a change in the code and see if it all works as expected and we see that change being promoted through our environments. It's about time for an end to end test.

The next diagram summarizes the end to end test you are going to run. As you can see, you will make a change to the code in the _Events API_ (*gramola-events*) which, via a webhook, will trigger the CI pipeline and hence the promotion of code. 

image::end-to-end-pipeline-1.png[End to End Pipeline Test]

These are the high level sequence of events (only relevant steps are mentioned here more details later on):

1. Change the code and push those changes to the repository of code (*gramola-events* in this case).
2. The *_Push Event_* is sent by the webhook to the *gramola-events CI Pipeline Event Listener* which in its turn triggers the pipeline by creating a *_PipelineRun_* object.
3. The `build` step builds the image for *gramola-events* and pushes it to the registry, the hash of the new image is used to update the _kustomization.yaml_ file in the _dev overlay_, in a short-lived feature-branch in the configuration repository (*gramola*)
4. A *_Pull Request_* is created for *merging* the `feature branch` with the `main branch` in the `pr-create` step.
5. The PR has to be confirmed so that changes are effectively merged into the main branch (this is a manual step)
6. Once the PR is confirmed, the merge is effective and a *_Pull Request Event_* is sent by the corresponding webhook to the *gramola-events CD Pipeline Event Listener* which in its turn triggers the pipeline by creating another *_PipelineRun_* object. At this point the hash of the new image has replaced the previous one.
7. The _CD pipeline fetches configuration not code_ and _in parallel triggers the sync of_ *events-app-dev* which means the new hash of the image is replaced in the Deployment object and hence a rolling update is triggered. Once the app is in sync a new PR is created to promote the code to the next environment.

Steps 6 and 7 are repeated for each environment until the code has been promoted to all of them.

Ok, done with the introduction, let's actually run through the demo.

[#change-the-code]
== Step 1: Change the code

In order to make the demonstration easier the *gramola-events* API has and endpoint `/info/name` that returns the value of a property (`info.name`) in the `application.properties` file. Let's change the value of that property

Copy the next URL to the gramola-events repository and paste it in a new tab.

[.console-input]
[source,bash, subs="+attributes"]
----
https://{gitea-host}/user1/gramola-events
----

You should land in the repository main page.

image::demo-step-1-0.png[gramola-events repository]

Signed in by using the *Sign in* link on the upper right corner (red rectangle). Credentials:

- *Username*: {username}
- *Password*: {password}

image::demo-step-1-1.png[gramola-events sign in]

Navigate to `src/main/resources/application.properties` then click on the pencil icon to edit the document directly.

image::demo-step-1-2.png[Navigate to application.properties]

Modify the value of property `info.name` add *{username}* as in the next picture so that you can later confirm the change has been promoted.

image::demo-step-1-3.png[Modify property info.name]

Commit changes, scroll down, add a commit message and click on the *Commit changes* button.

image::demo-step-1-4.png[Commit changes]

[#triggering-ci-pipeline]
== Step 2: Triggering the CI pipeline

The *Push Event* generated by the webhook defined in *gramola-events* repo triggers the pipeline named *events-ci-pl*. Let's check that out.

Copy the next url to the OpenShift console that should take you to the *Pipelines* area and open it in a new tab. Then have a look to the *events-ci-pl* pipeline which should have been triggered and hence running.

[.console-input]
[source,bash, subs="+attributes"]
----
https://{openshift-console-host}/dev-pipelines/ns/gramola-cicd-{username}
----

[NOTE]
====
Click on the *PLR* link to see the diagram of the on-going or finished pipeline run; or in the *Task Status Progress Bar* to see the *logs* of tasks and steps.
====

image::demo-step-2-1.png[CI Pipeline]

Click on the *PLR* link (red rectangle on the left), eventually you'll see something like this. As you can see this is the representation of the pipeline including the status (in this case all green) of the tasks and also if any of them were skipped (grayed out).

image::demo-step-2-2.png[CI Pipeline Run]

Pay attention to the last task. As you can see it is actually two tasks in parallel but only one (`gitea-pr-create`) has been run, the other one (`github-pr-create`) has been skipped because in this case the git provider is Gitea.

This is so because there is a _when expression_ in both tasks checking the GIT_PROVIDER parameter against *github* and *gitea* have a look to both tasks below.

NOTE: Open 


[tabs]
====
github-pr-create::
+
--
[source,yaml, subs="+macros,+attributes"]
----
  - name: github-pr-create
      ...
      runAfter:
        - update-image
      taskRef:
        kind: ClusterTask
        name: github-pr-create
      when: <1>
        - input: $(params.GIT_PROVIDER)
          operator: in
          values:
            - github
----
<1> This task is run if *GIT_PROVIDER* is *github*
--
gitea-pr-create::
+
--
[source,yaml, subs="+macros,+attributes"]
----
  - name: gitea-pr-create
      ...
      runAfter:
        - update-image
      taskRef:
        kind: ClusterTask
        name: gitea-pr-create
      when: <1>
        - input: $(params.GIT_PROVIDER)
          operator: in
          values:
            - gitea
----
<1> This task is run if *GIT_PROVIDER* is *gitea*
--
====


