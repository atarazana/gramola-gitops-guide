= Deploy CICD Pipelines With GitOps
include::_attributes.adoc[]

[#checking-cicd-pipelines]
== Checking pipelines

Well, so far we have used the command line to create the ArgoCD root application that in its turn has created all the needed elements:

- Cluster Tasks
- Pipelines
- Triggers

All those elements have been created in namespace devoted to CICD, let's have a look at the pipelines. Open the OpenShift web console and navigate to the CICD project (_red arrow_).

NOTE: Make sure that on the upper left corner the "Administrator" view is selected and that you are in the *'Home->Projects'* section.

image::pipelines-check-1.png[Pipelines Check 1]

Now navigate to 'Pipelines->Pipelines'. As you can see there are CI and CD pipelines for each microservice.

image::pipelines-check-2.png[Pipelines Check 2]

Le's have a look to the *CI pipeline* for the `Events` microservice *'events-ci-pl'*. As you can see is made of a series of tasks:

- *fetch-repository:* Fetches the `Events` code fro the Gitea repository you migrated before
- *package:* Compiles and packages the code in a JAR file
- *build:* Builds a container image, pushes it to the registry of images and saves the hash in an output variable
- *fetch-config-repository:* Fetches the configuration of Gramola (remember git is the source of truth for ArgoCD)
- *update-image:* Updates the hash in the *kustomization file* in the `dev` overlay of `Events` but in a short lived feature branch
- *gitea-pr-create:* Creates a *Pull Request* with the *feature branch* over the *main branch*
- *github-pr-create:* _N/A in this case we use Gitea_

NOTE: This is just an example covering the bare minimum tasks of a CI pipeline! Of course there should be other critical tasks such as: unit testing, code quality, ...

image::pipelines-check-3.png[Pipelines Check 3]

Navigate back and open the *CD pipeline*, again for `Events`, called *'events-cd-pl'*. This time the list of tasks is even shorter...

- *argocd-sync:* This triggers both the refresh from the configuration git repository and the assets synchronization
- *fetch-config-repository:* Fetches the configuration of Gramola (remember git is the source of truth for ArgoCD)
- *update-image:* Updates the hash in the *kustomization file* in the `dev` overlay of `Events` but in a short lived feature branch
- *gitea-pr-create:* Creates a *Pull Request* with the *feature branch* over the *main branch*
- *github-pr-create:* _N/A in this case we use Gitea_

image::pipelines-check-4.png[Pipelines Check 4]

Finally if you navigate to 'Pipelines->Triggers' you'll see there are many of them, we'll only use those for Gitea but the example is ready for receiving events from GitHub and GitLab. 

image::pipelines-check-5.png[Pipelines Check 5]

Well triggers are in place but we need web hooks to feed them!

[#create-pipeline-web-hooks]
== Create Pipeline Web Hooks

include::partial$gitea-create-webhooks.adoc[]
